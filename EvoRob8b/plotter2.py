import csv
import os
import config
import time
import datetime
import uuid
import re
import matplotlib.pyplot as plt

class Plotter:
    """ gathers data for plotting after ea """
    def __init__(self, filename: str = "", runID: str = ""):
        self.filename = filename
        self.runID = runID

        self.generations = []
        self.best_fitness = []
        self.worst_fitness = []
        self.mean_fitness = []
        self.median_fitness = []
        self.std = []
        self.num_modules_in_best_individual = []
        self.total_elapsed_time = []
        self.time_per_generation = []

    # --- helpers for automatic naming/saving/showing plots -----------------
    def _sanitize(self, s: object) -> str:
        """Return a filesystem-safe string for s."""
        return re.sub(r'[^A-Za-z0-9_.-]', '_', str(s))

    def _ensure_run_dir(self) -> str:
        """Ensure the run directory exists and return its path."""
        run_dir = os.path.join(config.LOG_FOLDER, str(self.runID))
        os.makedirs(run_dir, exist_ok=True)
        return run_dir

    def _generate_plot_filename(self, base: str = 'plot', ext: str = 'png', timestamp: bool = True, short_uuid: bool = False) -> str:
        parts = []
        if self.runID:
            parts.append(self._sanitize(self.runID))
        parts.append(self._sanitize(base))
        if timestamp:
            parts.append(datetime.datetime.now().strftime('%Y%m%d-%H%M%S'))
        if short_uuid:
            parts.append(uuid.uuid4().hex[:6])
        filename = '_'.join(parts) + '.' + ext.lstrip('.')
        return filename

    def _save_and_show(self, fig, base: str, ext: str = 'png', dpi: int = 150, short_uuid: bool = False) -> str:
        """Save the matplotlib Figure `fig` using an autogenerated name and show it.

        Returns the full path of the saved file.
        """
        run_dir = self._ensure_run_dir()
        filename = self._generate_plot_filename(base=base, ext=ext, timestamp=True, short_uuid=short_uuid)
        fullpath = os.path.join(run_dir, filename)
        fig.savefig(fullpath, dpi=dpi, bbox_inches='tight')
        # Try to set the GUI window title (backend-dependent)
        try:
            fig.canvas.manager.set_window_title(filename)
        except Exception:
            # Some backends or headless environments won't support this; ignore
            pass
        plt.show()
        return fullpath


    def log_generation(self, generation: int, best: float, worst: float, mean: float, median: float, std: float, num_modules: int, total_elapsed_time: float):
        self.generations.append(generation)
        self.best_fitness.append(best)
        self.worst_fitness.append(worst)
        self.mean_fitness.append(mean)
        self.median_fitness.append(median)
        self.std.append(std)
        self.num_modules_in_best_individual.append(num_modules)
        self.total_elapsed_time.append(total_elapsed_time)

        if generation == 0:
            self.time_per_generation.append(total_elapsed_time)
        else:
            self.time_per_generation.append(total_elapsed_time - self.total_elapsed_time[generation - 1])

    def save_to_csv(self, filename: str):
        # Use newline='' to avoid extra blank lines on some platforms
        with open(filename, 'w', newline='') as f:
            writer = csv.writer(f)
            writer.writerow(["generation", "best_fitness", "worst_fitness", "mean_fitness", "median_fitness", "std_fitness", "num_modules", "time_per_generation"])
            for i in range(len(self.generations)):
                writer.writerow([
                    self.generations[i],
                    self.best_fitness[i],
                    self.worst_fitness[i],
                    self.mean_fitness[i],
                    self.median_fitness[i],
                    self.std[i],
                    self.num_modules_in_best_individual[i],
                    self.time_per_generation[i]
                ])

    def append_last_n_to_csv(self, filename: str, n: int = 10):
        """Append the last `n` logged generations to a CSV file.

        If the file does not exist, a header will be written first.
        """
        if n <= 0:
            return

        start = max(0, len(self.generations) - n)
        if start >= len(self.generations):
            # Nothing to append
            return

        write_header = not os.path.exists(filename)

        # Use newline='' to avoid extra blank lines on some platforms
        with open(filename, 'a', newline='') as f:
            writer = csv.writer(f)
            if write_header:
                writer.writerow(["generation", "best_fitness", "worst_fitness", "mean_fitness", "median_fitness", "std_fitness", "num_modules", "time_per_generation", "total_elapsed_time"])

            for i in range(start, len(self.generations)):
                writer.writerow([
                    self.generations[i],
                    self.best_fitness[i],
                    self.worst_fitness[i],
                    self.mean_fitness[i],
                    self.median_fitness[i],
                    self.std[i],
                    self.num_modules_in_best_individual[i],
                    self.time_per_generation[i],
                    self.total_elapsed_time[i]
                ])

    def load_from_csv(self, filename: str):
        with open(filename, 'r') as f:
            reader = csv.reader(f)
            next(reader)  # skip header
            for row in reader:
                self.generations.append(int(row[0]))
                self.best_fitness.append(float(row[1]))
                self.worst_fitness.append(float(row[2]))
                self.mean_fitness.append(float(row[3]))
                self.median_fitness.append(float(row[4]))
                self.std.append(float(row[5]))
                self.num_modules_in_best_individual.append(int(row[6]))

    def plot_best_worst(self):
        fig = plt.figure(figsize=(10, 6))
        plt.plot(self.generations, self.best_fitness, label='Best Fitness')
        plt.plot(self.generations, self.worst_fitness, label='Worst Fitness')
        plt.plot(self.generations, self.mean_fitness, label='Mean Fitness')

        plt.xlabel('Generation')
        plt.ylabel('Fitness')
        plt.title('EA progression')
        plt.legend()
        plt.grid()
        return self._save_and_show(fig, base='fitness_progression')

    def boxplot_fitness(self):

        data = [self.best_fitness, self.worst_fitness, self.mean_fitness]
        fig = plt.figure(figsize=(10, 6))
        plt.boxplot(data, labels=['Best Fitness', 'Worst Fitness', 'Mean Fitness'])

        plt.ylabel('Fitness')
        plt.title('Fitness Distribution')
        plt.grid()
        return self._save_and_show(fig, base='fitness_boxplot')
    
    def plot_std(self):

        fig = plt.figure(figsize=(10, 6))
        plt.plot(self.generations, self.std, label='Standard Deviation')

        plt.xlabel('Generation')
        plt.ylabel('Standard Deviation')
        plt.title('EA progression')
        plt.legend()
        plt.grid()
        return self._save_and_show(fig, base='std_progression')

    def plot_num_modules(self):

        fig = plt.figure(figsize=(10, 6))
        plt.plot(self.generations, self.num_modules_in_best_individual, label='Num Modules in Best Individual')

        plt.xlabel('Generation')
        plt.ylabel('Number of modules')
        plt.title('EA progression')
        plt.legend()
        plt.grid()
        return self._save_and_show(fig, base='num_modules_progression')

    def plot_time_per_generation(self):

        fig = plt.figure(figsize=(10, 6))
        plt.plot(self.generations, self.time_per_generation, label='Time per Generation')

        plt.xlabel('Generation')
        plt.ylabel('Time (seconds)')
        plt.title('Time per Generation')
        plt.legend()
        plt.grid()
        return self._save_and_show(fig, base='time_per_generation')

if __name__ == "__main__":
    """ Cannot run over ssh bc of plotting """
    run_id = input("> run ID: ")
    plotter = Plotter(runID=run_id)
    plotter.load_from_csv(config.LOG_FOLDER + f"{run_id}/progress.csv")
    plotter.plot_best_worst()
    plotter.boxplot_fitness()
    plotter.plot_std()
    plotter.plot_num_modules()
    plotter.plot_time_per_generation()

